##
## Quick and dirty
##
alias aptup='sudo apt-get update; sudo apt-get dist-upgrade'
[ `uname` = Darwin ] && alias top='top -o cpu'
gman () { man $* | col -b | gview - }
srcgrep () {
    grep -r "$*" . | grep -v tags | grep -v \\.svn| grep -v \\.git | grep -v "Binary file"
}


bindkey -e
bindkey '^u' backward-kill-line
bindkey '\eq' push-line-or-edit

# Beeping is rude.
setopt no_beep

# Retain literal '*' when there's no glob match.  This is sloppy but useful.
setopt no_nomatch

HISTFILE=$HOME/.history
HISTSIZE=10100
SAVEHIST=10000
setopt inc_append_history  # fc -RI to import from other shells.


##
## Saturn Valley Intergalactic Standard Command Prompt
##
typeset -ga precmd_functions
typeset -ga chpwd_functions
typeset -ga preexec_functions

function set_git_prompt {
  gitref=$(git symbolic-ref HEAD 2> /dev/null)
  if [[ -n $gitref ]] ; then
    gitbranch="[${gitref#refs/heads/}]"
  else
    gitbranch=""
  fi
  RPROMPT="${gitbranch}"
}

function zsh_git_prompt_precmd {
  if [[ -n "$PR_GIT_UPDATE" ]] ; then
    set_git_prompt
    PR_GIT_UPDATE=
  fi
}
precmd_functions+='zsh_git_prompt_precmd'

function zsh_git_prompt_chpwd {
  PR_GIT_UPDATE=1
}
chpwd_functions+='zsh_git_prompt_chpwd'

function zsh_git_prompt_preexec {
  case "$(history $HISTCMD)" in 
  *git*)
    PR_GIT_UPDATE=1
    ;;
  esac
}
preexec_functions+='zsh_git_prompt_preexec'

PR_GIT_UPDATE=1

# TODO(jleen): I should be able to do "function {" and get an anonymous scope
# that's executed immediately.  Maybe it only works on versions > 4.3.4, which
# is what Leopard gives me?
setprompt () {
  [ -n "$HOST" ] && host="$HOST" || host=`uname -n`
  local short_host=`echo ${host}|cut -d. -f1`
  if [ "$TERM" = "dumb" ]; then
    # We're probably in Emacs M-x shell.
    PROMPT='${short_host} [%~]%# '
  else
    if [ -n "$WINDOW" ]; then
      local screen=":$WINDOW"
      local screen_clear="`print \\\\ek\\\\e\\\\134`"
    fi
    if [[ $TERM = (xterm*|rxvt*|screen|cygwin) ]]; then
      local xterm="`print \\\\e`]0;$SHELLPREFIX${short_host}${screen}:%~`print \\\\007`"
    fi
    if [ -n "$SHELLPREFIX" ]; then
      local prefix="%{`tput setaf 0``tput bold`%}$SHELLPREFIX%{`tput sgr0`%}"
    fi
    local cruft="%{${screen_clear}${xterm}${shellprefix}%}"
    local color_on="%{`tput setaf ${SHELLCOLOR:-4}``tput bold`%}"
    local color_off="%{`tput sgr0`%}"
    setopt prompt_subst
    PROMPT="${cruft}${prefix}${color_on}${short_host}${screen}${color_off} [\${SV_PWD_PROMPT:-%~}]%# "
  fi
}
setprompt
unfunction setprompt


##
## Saturn Valley Pandimensional Uniform Editor Launcher
##
if [ "$SVPLATFORM" = cygwin ]; then
  v () {
    if [ -z "$*" ]; then
      cygstart --hide gvim.bat
    else
      for fn in "$@"; do
        local winfn="`cygpath -wa "$fn"`"
        cygstart --hide gvim.bat "\"$winfn\""
      done
    fi
  }
  alias vv='gvim.bat -R -'
elif [ "$SVPLATFORM" = mac ]; then
  v () {
    if [ -z "$*" ]; then
      mvim
    else
      for fn in "$@"; do
        mvim "$fn"
      done
    fi
  }
  alias vv='mvim -R - > /dev/null'
else
  v () {
    if [ "$SVPLATFORM" = X11 ]; then
      if [ -z "$*" ]; then
        gvim
      else
        for fn in "$@"; do
          gvim "$fn"
        done
      fi
    elif [ "$SVPLATFORM" = screen ]; then
      # screen runs as root, and thus has weird chdir problems when root can't
      # read the pwd (e.g. when it's on NFS.)  So we hack around the issue.
      local filepwd="$PWD"
      pushd -q /
      if [ -z "$*" ]; then
        screen -t vi vi --cmd "cd $filepwd"
      else
        for fn in "$@"; do
          screen -t "vi $fn" vi --cmd "cd $filepwd" "$filepwd/$fn"
        done
      fi
      popd -q
    else
      vi "$@"
    fi
  }
  vv () {
    if [ "SVPLATFORM" = X11 ]; then
      gvim -R -
    else
      vi -R -
    fi
  }
fi


##
## Private Temp Dir
##
SVTMP="$TMPPREFIX-$USERNAME-sv"
if [ -e "$SVTMP" ]; then
  if [[ ! ( -O "$SVTMP" && -d "$SVTMP" ) ]]; then
    echo "Bad $SVTMP"
    unset SVTMP
  fi
else
  if mkdir -pm 700 "$SVTMP" 2> /dev/null; then
    echo "Created $SVTMP"
  elif [[ -O "$SVTMP" && -d "$SVTMP" ]]; then
    echo "Another process created $SVTMP for us, yay"
  else
    echo "Unable to create $SVTMP"
    unset SVTMP
  fi
fi


##
## Screen Meta-Management
##
SCREENENV="$SVTMP/screenenv"

ss () {
  if [ -n "$WINDOW" ]; then
    echo "You have your slaw, sir!"
  else
    [ -n "$SCREENENV" ] && echo "" > "$SCREENENV"
    if screen -ls | grep -q prime; then
      if [ -n "$SCREENENV" ]; then
        for var in DISPLAY XAUTHORITY DBUS_SESSION_BUS_ADDRESS; do
          local val=${(P)var}
          screen -S prime -X setenv $var "$val"
          echo "$var=$val" >> "$SCREENENV"
        done
      fi
      screen -x prime
    else
      screen -S prime
    fi
  fi
}

if [[ -n "$WINDOW" && -n "$SCREENENV" ]]; then
  function snarf_screen_env {
    local record
    for record in `cat "$SCREENENV"`; do
      case $record in
        DISPLAY*|XAUTHORITY*|DBUS_SESSION_BUS_ADDRESS*) export $record;;
      esac
    done
    set_platform
    set_editor
  }

  precmd_functions+='snarf_screen_env'
  preexec_functions+='snarf_screen_env'
fi

##
## Color ls
##
if [ "$TERM" != "dumb" ] && which dircolors > /dev/null; then
  eval "`dircolors -b`"
  alias ls='ls -F --color=auto'
elif [ "$TERM_PROGRAM" = Apple_Terminal ]; then
  alias ls='ls -FG'
else
  alias ls='ls -F'
fi

##
## Don't delete so much.
## Adapted from http://www.zsh.org/mla/users/2009/msg00589.html .
##
_my_extended_wordchars='*?[]~&;!#$%^(){}<>@\\';
_my_extended_wordchars_space="${my_extended_wordchars} "
_my_extended_wordchars_slash="${my_extended_wordchars}/"

# is the current position \-quoted ?
function _is_quoted(){
  test "${BUFFER[$CURSOR-1,CURSOR-1]}" = "\\"
}

_unquote-backward-delete-word(){
  while  _is_quoted
    do zle .backward-kill-word
  done
}

_unquote-forward-delete-word(){
  while  _is_quoted
    do zle .kill-word
  done
}

_unquote-backward-word(){
  while  _is_quoted
    do zle .backward-word
  done
}

_unquote-forward-word(){
  while _is_quoted
    do zle .forward-word
  done
}

_backward-delete-to-space() {
  local WORDCHARS=${_my_extended_wordchars_slash}
  zle .backward-kill-word
  _unquote-backward-delete-word
}

_backward-delete-to-/ () {
  local WORDCHARS=${_my_extended_wordchars}
  zle .backward-kill-word
  _unquote-backward-delete-word
}

_forward-delete-to-space() {
  local WORDCHARS=${_my_extended_wordchars_slash}
  zle .kill-word
  _unquote-forward-delete-word
}

_forward-delete-to-/ () {
  local WORDCHARS=${_my_extended_wordchars}
  zle .kill-word
  _unquote-forward-delete-word
}

_backward-to-space() {
  local WORDCHARS=${_my_extended_wordchars_slash}
  zle .backward-word
  _unquote-backward-word
}

_forward-to-space() {
   local WORDCHARS=${_my_extended_wordchars_slash}
   zle .forward-word
   _unquote-forward-word
}

_backward-to-/ () {
  local WORDCHARS=${_my_extended_wordchars}
  zle .backward-word
  _unquote-backward-word
}

_forward-to-/ () {
  local WORDCHARS=${_my_extended_wordchars}
  zle .forward-word
  _unquote-forward-word
}

zle -N _backward-delete-to-/
zle -N _forward-delete-to-/
zle -N _backward-delete-to-space
zle -N _forward-delete-to-space
zle -N _backward-to-/
zle -N _forward-to-/
bindkey '^w'       _backward-delete-to-/
bindkey "^[b"      _backward-to-/
bindkey "^[f"      _forward-to-/
bindkey "^[^?"     _backward-delete-to-/
bindkey "^[d"      _forward-delete-to-/
# xterm
bindkey "^[[3;3~"  _forward-delete-to-/
bindkey "^[[1;3C" _forward-to-/
bindkey "^[[1;3D" _backward-to-/
# Terminal.app
bindkey "^[[5C" _forward-to-/
bindkey "^[[5D" _backward-to-/
bindkey "^[^[[C"  _forward-to-/
bindkey "^[^[[D"  _backward-to-/
# Why does Skai need these other Terminal.app codes?  10.5 versus 10.6 maybe?
bindkey "^[O5C" _forward-to-/
bindkey "^[O5D" _backward-to-/
# PuTTY
# TODO(jleen): Why did we want these next two?  They break ssh from Darwin.
#bindkey "^[OC" _forward-to-/
#bindkey "^[OD" _backward-to-/
bindkey "^[[1~" beginning-of-line
bindkey "^[[4~" end-of-line
# xterm over NX on Leopard (bite me)
bindkey "^[[1;9C" _forward-to-/
bindkey "^[[1;9D" _backward-to-/


##
## But wait--there's more (maybe)!
##
[ "$OSTYPE" = cygwin ] && source "$SVCONFIGDIR/cygwin/zshrc"
